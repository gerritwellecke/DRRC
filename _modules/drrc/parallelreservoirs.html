<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>drrc.parallelreservoirs &mdash; drrc  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9bcbadda"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            drrc
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Content</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/index.html">1. User manual</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../manual/installation.html">1.1. Installing drrc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/installation.html#installing-the-needed-packages">1.1.1. Installing the Needed Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../manual/installation.html#editable-installation-of-development-stage-code">1.1.2. Editable Installation of Development-Stage Code</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/generating_data.html">1.2. Genration of training data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/generating_data.html#creating-1d-kuramoto-sivashinsky-data">1.2.1. Creating 1D Kuramoto-Sivashinsky Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../manual/generating_data.html#creating-2d-data">1.2.2. Creating 2D Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/cluster.html">1.3. Running a job on the cluster</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/cluster.html#installing-python-on-the-cluster">1.3.1. Installing python on the cluster</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../manual/cluster.html#at-mpi-ds">1.3.1.1. At MPI-DS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../manual/cluster.html#at-gwdg">1.3.1.2. At GWDG</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../manual/cluster.html#submission-scripts">1.3.2. Submission Scripts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/analysis.html">1.4. Analysing raw cluster output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/contributing.html">1.5. Contributing to DRRC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/contributing.html#automated-documentation">1.5.1. Automated Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../manual/contributing.html#first-steps-to-work-in-this-repository">1.5.2. First steps to work in this repository</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../manual/contributing.html#working-in-this-repository">1.5.3. Working in this repository</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../manual/contributing.html#avoiding-it-works-on-my-machine-like-problems">1.5.3.1. Avoiding “it works on my machine”-like problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../manual/contributing.html#formatting-code">1.5.3.2. Formatting Code</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/manuscript.html">1.6. The Manuscript</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/manuscript.html#generating-plots-for-this-project">1.6.1. Generating Plots for this Project</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/testing.html">1.7. Automated Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../manual/testing.html#workflow-and-local-testing">1.7.1. Workflow and local testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../manual/open_questions.html">1.8. Open Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../packages/drrc.html">2. drrc</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.tools.html">2.1. drrc.tools package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../packages/drrc.tools.general_methods.html">2.1.1. drrc.tools.general_methods module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../packages/drrc.tools.logger_config.html">2.1.2. drrc.tools.logger_config module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../packages/drrc.tools.plot_config.html">2.1.3. drrc.tools.plot_config module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../packages/drrc.tools.visualization.html">2.1.4. drrc.tools.visualization module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.analysis.html">2.2. drrc.analysis module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.config.html">2.3. drrc.config module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.kuramoto_sivashinsky.html">2.4. drrc.kuramoto_sivashinsky module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.parallelreservoirs.html">2.5. drrc.parallelreservoirs module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.reservoircomputer.html">2.6. drrc.reservoircomputer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../packages/drrc.spatially_extended_systems.html">2.7. drrc.spatially_extended_systems module</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../CHANGELOG.html#unpublished-2025-10-02">UNPUBLISHED – 2025/10/02</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">drrc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">drrc.parallelreservoirs</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for drrc.parallelreservoirs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the implementation of the ParallelReservoirsBase class, three coresponding subclasses ParallelReservoirs, ParallelReservoirsFFT and ParallelReservoirsPCA and the ParallelReservoirsArguments dataclass.</span>

<span class="sd">The Subclasses are used to predict high dimensional (spatially extended) systems using multiple Reservoir Computers in parallel:</span>
<span class="sd">    1. The ParallelReservoirs class is used for high dimensional systems, without a dimension reduction.</span>
<span class="sd">    2. The ParallelReservoirsFFT class is used for high dimensional systems, using only a selection of fft modes as a dimension reduction.</span>
<span class="sd">    3. The ParallelReservoirsPCA class is used for high dimensional systems, using only a selection of pca modes as a dimension reduction.</span>

<span class="sd">The base class :code:`ParallelReservoirsBase` contains everything for parallel reservoir applications that predicts high dimensional (spatially extended) systems using multiple Reservoir Computers in parallel.</span>
<span class="sd">The classes use a class instance of :code:`ParallelReservoirsArguments`, which is a dataclass that represents the parameters for configuring the (parallel-) reservoirs.</span>

<span class="sd">Author: Luk Fleddermann, Gerrit Wellecke</span>
<span class="sd">Date: 13.06.2024</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">log</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">paths</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">fields</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">drrc.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">Config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">drrc.reservoircomputer</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReservoirComputer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">drrc.tools.logger_config</span><span class="w"> </span><span class="kn">import</span> <span class="n">drrc_logger</span> <span class="k">as</span> <span class="n">logger</span>

<span class="c1"># NOTE: what ParallelReservoirsX are supposed to do:</span>
<span class="c1"># - Implement the use of multi-reservoirs</span>
<span class="c1"># - Contain a list of those reservoirs</span>
<span class="c1"># - Train a reservoir for each of the subdomains or alternatively train one reservoir on</span>
<span class="c1">#   all subdomains</span>
<span class="c1"># - Handle the training &amp; output data w.r.t. linear transformations</span>
<span class="c1">#   (currently PCA &amp; FFT) and boundary conditions (through ghost cells)</span>

<span class="c1"># Coding</span>
<span class="c1"># TODO: JIT the _boundary_condition and _evaluation_one_step, this is used in every prediction step</span>
<span class="c1"># TODO: Maybe add tqdm to Training loop of reservoirs, decide what we want there some times the number is 1-4 sometimes up to at least 2000</span>

<span class="c1"># Testing and documentation</span>
<span class="c1"># TODO: write wrong parameter usage function. For instance, ParallelReservoirs should not have dimensionreduction</span>
<span class="c1"># TODO: Insert wrong arguments checking for all non-internal functions (init, train, itterative_predict, reservoir_transient)</span>
<span class="c1"># TODO: remove class variables from documentation</span>

<span class="c1"># get logging levels</span>
<span class="n">loglevel_debug_parallelreservoirs</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="s2">&quot;DEBUG_PRC&quot;</span><span class="p">)</span>
<span class="n">loglevel_debug_DRRC</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="s2">&quot;DEBUG_DRRC&quot;</span><span class="p">)</span>

<span class="n">loglevel_info_single_run</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="s2">&quot;INFO_1RUN&quot;</span><span class="p">)</span>
<span class="n">loglevel_info_multiple_run</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getLevelName</span><span class="p">(</span><span class="s2">&quot;INFO_nRUN&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ParallelReservoirsArguments">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsArguments">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelReservoirsArguments</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parallel-reservoir parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        adjacency_degree (int):</span>
<span class="sd">            average degree of the adjacency matrix</span>
<span class="sd">        adjacency_dense (bool):</span>
<span class="sd">            whether the adjacency matrix is sparse (False) or dense (True)</span>
<span class="sd">        adjacency_spectralradius (float):</span>
<span class="sd">            spectral radius, largest eigenvalue of the adjacency matrix</span>
<span class="sd">        reservoir_leakage (float):</span>
<span class="sd">            leakage the strength of memory a reservoir state remembers old</span>
<span class="sd">            excitations with (0.0 only driven from new data no memory, 1.0 no update</span>
<span class="sd">            of rs)</span>
<span class="sd">        reservoir_nodes (int):</span>
<span class="sd">            number of nodes in each of the parallel reservoirs</span>
<span class="sd">        input_scaling (float):</span>
<span class="sd">            input scaling the maximal absolute value of entries in the input matrix</span>
<span class="sd">        input_bias (float):</span>
<span class="sd">            scaling of the bias strength double the maximal absolute value of the</span>
<span class="sd">            bias input to a reservoir node, None defaults to inscale</span>
<span class="sd">        spatial_shape (tuple[int, ...]):</span>
<span class="sd">            shape of the input data, without boundary condition (for ex. :code:`(128,)` in 1D case, :code:`(128,128)` in 2D case)</span>
<span class="sd">        system_variables (int):</span>
<span class="sd">            number of variables in the system (data for one time step is of shape :code:`(system_variables, *spatial_shape)`).</span>
<span class="sd">        boundary_condition (str):</span>
<span class="sd">            the type of boundary condition to apply to the input data</span>
<span class="sd">        parallelreservoirs_grid_shape (tuple[int, ...]):</span>
<span class="sd">            the amount of reservoirs per dimension that should be used together as a</span>
<span class="sd">            multi-reservoir (for ex. [2,1] in 2D case for 2 reservoirs in</span>
<span class="sd">            x direction)</span>
<span class="sd">        parallelreservoirs_ghosts (int):</span>
<span class="sd">            number of variables that a reservoir sees from outside the region where</span>
<span class="sd">            its predicting for sync.</span>
<span class="sd">        dimensionreduction_fraction (float):</span>
<span class="sd">            fraction of variables that actually enters the reservoir after</span>
<span class="sd">            dimension reduction</span>
<span class="sd">        training_includeinput (bool):</span>
<span class="sd">            whether to also fit the input signal for predicting the next timestep</span>
<span class="sd">        training_regularization (float):</span>
<span class="sd">            regularization strength for the ridge regression</span>
<span class="sd">        training_output_bias (float):</span>
<span class="sd">            scaling of the output bias</span>
<span class="sd">        identical_inputmatrix (bool):</span>
<span class="sd">            whether we use different input matrices for each reservoir</span>
<span class="sd">        identical_adjacency (bool):</span>
<span class="sd">            whether we use different adjacency matrices for each reservoir</span>
<span class="sd">        identical_outputmatrix (bool | str | tuple[int, ...]):</span>
<span class="sd">            whether we train each domain with a separate reservoir (False) or one</span>
<span class="sd">            reservoir on all domains (&#39;combine_data&#39;) or one reservoir on one domain (tuple of indices)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adjacency_degree</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">adjacency_dense</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">adjacency_spectralradius</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">reservoir_leakage</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">reservoir_nodes</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">input_scaling</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">input_bias</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">spatial_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">system_variables</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">boundary_condition</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">parallelreservoirs_grid_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">parallelreservoirs_ghosts</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">dimensionreduction_fraction</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">training_includeinput</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">training_regularization</span><span class="p">:</span> <span class="nb">float</span>

    <span class="n">training_output_bias</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">identical_inputmatrix</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">identical_adjacencymatrix</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">identical_outputmatrix</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="c1"># maybe deprecated, not used yet</span>
    <span class="c1"># training_overwrite: bool</span>
    <span class="c1"># dtype: str</span>
    <span class="c1"># deprecated_trainonly: bool</span>

<div class="viewcode-block" id="ParallelReservoirsArguments.from_config">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsArguments.from_config">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">conf</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span> <span class="n">job_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sub_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a ParallelReservoirsArguments object from a Config object.</span>

<span class="sd">        This method generates a ParallelReservoirsArguments object based on the provided Config object.</span>
<span class="sd">        The Config object should have keys that match the names defined in this class.</span>

<span class="sd">        Args:</span>
<span class="sd">            conf (Config): The Config object corresponding to the YAML for the parameter scan.</span>
<span class="sd">            idx (int): The index of the current parameter set.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ParallelReservoirsArguments: The generated ParallelReservoirsArguments object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">param_scan_list</span><span class="p">()[</span><span class="n">job_idx</span><span class="p">][</span><span class="n">sub_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">pass</span>
        <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">])</span>
        <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">del</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;training_data_index&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsArguments.from_dict">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsArguments.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate parameters from dictionary</span>

<span class="sd">        This function supports passing of a dictionary that contains more than the</span>
<span class="sd">        needed keys. In this case any additional information is simply ignored.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_dict:</span>
<span class="sd">                dictionary containing at least all the needed keys for the</span>
<span class="sd">                initialiser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">class_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">)}</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;identical_outputmatrix&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;spatial_shape&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">input_dict</span><span class="p">[</span><span class="s2">&quot;parallelreservoirs_grid_shape&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">class_fields</span><span class="p">})</span></div>
</div>



<div class="viewcode-block" id="ParallelReservoirsBase">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelReservoirsBase</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for parallel reservoir applications. Implements the use of multiple Reservoir Computers in parallel to predict high dimensional (spatially extended) systems.</span>
<span class="sd">    Parallel is to be understood in terms of domain splitting of the input data.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">ParallelReservoirsArguments</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        - Base class: Set up reservoir and parallel-reservoir parameters, initialize reservoirs and slices.</span>

<span class="sd">        Args:</span>

<span class="sd">            args (ParallelReservoirsArguments):</span>
<span class="sd">                All needed arguments in a dataclass object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="s2">&quot;Initializing ParallelReservoirsBase.&quot;</span><span class="p">)</span>
        <span class="c1"># set data input parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">spatial_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system_variables</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">system_variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">boundary_condition</span>

        <span class="c1"># set reservoir parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_degree</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">adjacency_degree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_dense</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">adjacency_dense</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_spectralrad</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">adjacency_spectralradius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_leakage</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">reservoir_leakage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_nodes</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">reservoir_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_scaling</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">input_scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_bias</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">input_bias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_bias</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">training_output_bias</span>

        <span class="c1"># set multi-reservoir parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">parallelreservoirs_grid_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">parallelreservoirs_ghosts</span>

        <span class="c1"># set dimensionality reduction parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">dimensionreduction_fraction</span>

        <span class="c1"># set training parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_includeinput</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">training_includeinput</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_regularization</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">training_regularization</span>

        <span class="c1"># how many matrices are used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identical_input</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">identical_inputmatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identical_adjacencymatrix</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">identical_adjacencymatrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">identical_outputmatrix</span>

        <span class="c1"># check if identical matrices are set correctly</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identical_adjacencymatrix</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identical_adjacencymatrix</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Identical output matrix requires identical adjacency matrix. Identical adjacency matrix is set to True.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identical_input</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identical_input</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Identical output matrix requires identical input matrix. Identical input matrix is set to True.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># deprecated parameters (just in case)</span>
        <span class="c1"># self.dtype = args.dtype</span>
        <span class="c1"># self.deprecated_trainonly = args.deprecated_trainonly</span>
        <span class="c1"># self.train_overwrite = args.training_overwrite</span>

        <span class="c1"># Calculate the shape of the domain on which each reservoir predicts. To this shape the reservoirs output will be reshaped. Data of this shape is transformed and dimension reduced to create the input.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">system_variables</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span> <span class="o">//</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">)</span>
            <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># res_inpu_length depends on dimensionreduction and is set in the derived classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_input_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_input_length</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.__init__</span><span class="se">\t\t\t</span><span class="s2">Reservoir output shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2">, Reservoir input length: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_input_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># TODO write seed somewhere!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_reservoirs</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># set up slices</span>
        <span class="c1">## one prediction slice for all reservoirs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1">## one input slice for each reservoir: list of slicing objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_reservoir_slices</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="s2">&quot;Done.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ParallelReservoirsBase.train">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase.train">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">input_training_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">output_training_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">transient_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Train the output matrix of all parallel reservoirs using ridge regression.</span>
<span class="sd">        Hereby it is differentiated between different methods:</span>

<span class="sd">        1. Each reservoir is trained individually. Works for arbirary systems.</span>

<span class="sd">        2. One reservoir (used for the predictions of all domains) is trained on one domain only. Works only for homogenious systems.</span>

<span class="sd">        3. One reservoir (used for the predictions of all domains) is trained on all domains by combigning the data. Works only for homogenious systems.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_training_data: np.ndarray[float]</span>
<span class="sd">                input data for training, without bouncary condition ghostcells. Data needs to be of shape :code:`(time_steps, variables, *spatial_shape)`.</span>
<span class="sd">            output_training_data: np.ndarray[float]</span>
<span class="sd">                output data for training, without bouncary condition ghostcells. Data needs to be of shape :code:`(time_steps - transient_steps, variables, *spatial_shape)`.</span>
<span class="sd">            transient_steps: int, optional</span>
<span class="sd">                number of transient steps to be used for training (default: 0)</span>

<span class="sd">        Notes:</span>
<span class="sd">            The training method includes a transient phase, where the reservoirs are driven by the input data without using the results for the training.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Training parallel reservoirs.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.train</span><span class="se">\t\t\t\t</span><span class="s2">Training input, without ghostcells shape: </span><span class="si">{</span><span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.train</span><span class="se">\t\t\t\t</span><span class="s2">Training output, without ghostcells shape: </span><span class="si">{</span><span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">input_training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
            <span class="n">input_training_data</span><span class="p">,</span>
            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">output_training_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
            <span class="n">output_training_data</span><span class="p">,</span>
            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.train</span><span class="se">\t\t\t\t</span><span class="s2">Training input, with ghost cells shape: </span><span class="si">{</span><span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.train</span><span class="se">\t\t\t\t</span><span class="s2">Training output, with ghosts cells shape: </span><span class="si">{</span><span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Test data shapes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Data must have shape (time_steps, variables, *spatial_shape), but have shape input_shape = </span><span class="si">{</span><span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and output_shape = </span><span class="si">{</span><span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">!=</span> <span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">transient_steps</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Input and output training data must have the same length (only input is supposed to include transient). But input is of shape </span><span class="si">{</span><span class="n">input_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, output is of shape </span><span class="si">{</span><span class="n">output_training_data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and transient_steps is </span><span class="si">{</span><span class="n">transient_steps</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Test training specifying variables:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Identical output reservoir index </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="si">}</span><span class="s2"> is out of bounds. Number of reservoirs is </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># distinguish between different trainings</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># train all reservoirs individually</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                <span class="n">res</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
                    <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                        <span class="n">input_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                        <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                        <span class="n">output_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">fraction</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">),</span>
                    <span class="n">transient_steps</span><span class="o">=</span><span class="n">transient_steps</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># train one reservoir on one domain</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">train</span><span class="p">(</span>
                <span class="nb">input</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                    <span class="n">input_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]],</span>
                    <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">output</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                    <span class="n">output_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">idx</span><span class="p">]],</span> <span class="n">fraction</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">),</span>
                <span class="n">transient_steps</span><span class="o">=</span><span class="n">transient_steps</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span> <span class="o">==</span> <span class="s2">&quot;combine_data&quot;</span><span class="p">:</span>
            <span class="c1"># train one reservoir on all domains</span>
            <span class="c1">## stack spatial data to a list of trainingdatasets</span>
            <span class="n">input_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                    <span class="n">input_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                    <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">output_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                    <span class="n">output_training_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">fraction</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># train the first reservoir on all datasets</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">train_on_multiple_datasets</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">input_data</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_data</span><span class="p">,</span> <span class="n">transient_steps</span><span class="o">=</span><span class="n">transient_steps</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Identical output matrix needs to be False, tuple or &#39;combine_data&#39;, but is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase.iterative_predict">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase.iterative_predict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iterative_predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">,</span> <span class="n">supervision_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iteratively predict a time series.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial (np.ndarray[float]):</span>
<span class="sd">                Initial condition for the time series prediction.</span>
<span class="sd">            max_steps (int):</span>
<span class="sd">                Maximum number of steps to predict.</span>
<span class="sd">            supervision_data (np.ndarray[float], optional):</span>
<span class="sd">                Supervision data for evaluating the prediction.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            **kwargs:</span>
<span class="sd">                Additional keyword arguments for evaluating the prediction:</span>
<span class="sd">                Including an error function :code:`error_function` of {&#39;NRMSE&#39;},</span>
<span class="sd">                the (temporal) mean of the norm of the data :code:`mean_norm`,</span>
<span class="sd">                a threshhold value for the error function :code:`error_stop`,</span>
<span class="sd">                and the number of extra steps to predict after the error threshold is exceeded :code:`extra_steps`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[np.ndarray, np.ndarray | None, int]:</span>
<span class="sd">                A tuple containing the predicted time series,</span>
<span class="sd">                the prediction errors (if supervision data is provided, else None),</span>
<span class="sd">                and the number of steps predicted.</span>

<span class="sd">        Notes: Before the prediction the parallel reservoir states need to be adjusted to the state of the system to be predicted by using :code:`reservoir_transient`.</span>

<span class="sd">        Warning: This function with supervision data is not tested nor fully implemented yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Iteratively predicting time series.&quot;</span><span class="p">)</span>

        <span class="c1"># add ghostcells to initial data to fullfill boundary condition, and create prediction place holder</span>
        <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">max_steps</span><span class="p">,</span> <span class="o">*</span><span class="n">initial</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.iterative_predict</span><span class="se">\t\t</span><span class="s2">Initial shape: </span><span class="si">{</span><span class="n">initial</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.iterative_predict</span><span class="se">\t\t</span><span class="s2">Prediction shape: </span><span class="si">{</span><span class="n">prediction</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Decide whether to predict with supervision data or not, if not max_steps time steps are predicted, else the _evaluate_one_step function is used to stop the prediction</span>
        <span class="k">if</span> <span class="n">supervision_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_steps</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_transform_data</span><span class="p">(</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">predict_single_step</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                                <span class="n">initial</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span>

                <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># return inner prediction/ neglect ghostcells</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: This could be modified. I test here all arguments needed for evaluation of a prediction.</span>
            <span class="c1"># TODO: The parameters are set as kwargs, because they dont belong to the class, but to this prediciton</span>

            <span class="c1"># Checking arguments for iterative predction</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">error_function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;error_function&quot;</span><span class="p">]</span>
                <span class="n">error_stop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;error_stop&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Errorfunction &#39;error_function&#39; and threshhold value &#39;error_stop&#39; need to be set to evaluate predictions.&quot;</span>
                <span class="p">)</span>
            <span class="c1"># setting number of steps after threshold is exceeded</span>
            <span class="k">if</span> <span class="s2">&quot;extra_steps&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">extra_steps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;extra_steps&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra_steps</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or any default value</span>

            <span class="c1"># setting error function</span>
            <span class="k">if</span> <span class="n">error_function</span> <span class="o">==</span> <span class="s2">&quot;NRMSE&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mean_norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;mean_norm&quot;</span><span class="p">]</span>

                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Mean norm of data need to be set as keyword arguments to evaluate predictions.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Only Normalized Root Mean Square Error &#39;NRMSE&#39; is implemented so far.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># create variables</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_steps</span><span class="p">)</span>
            <span class="n">good_prediction</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># iteratively predict and measure error</span>
            <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">max_steps</span> <span class="ow">and</span> <span class="n">good_prediction</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_transform_data</span><span class="p">(</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">predict_single_step</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                                <span class="n">initial</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span>

                <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

                <span class="c1"># measure error, prediction slice is used to compare only the inner part of the data/ neglect ghost cells</span>
                <span class="n">good_prediction</span><span class="p">,</span> <span class="n">errors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_one_step</span><span class="p">(</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span><span class="p">],</span>
                    <span class="n">supervision_data</span><span class="p">[</span><span class="n">t</span><span class="p">],</span>
                    <span class="n">errrofunction</span><span class="o">=</span><span class="n">error_function</span><span class="p">,</span>
                    <span class="n">mean_norm</span><span class="o">=</span><span class="n">mean_norm</span><span class="p">,</span>
                    <span class="n">error_stop</span><span class="o">=</span><span class="n">error_stop</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># TODO: Hier muessen noch parameter von _evaluate_one_step gesetzt werden, die nicht allgemein in der baseclass sein muessen: Kwargs?</span>
                <span class="c1"># TODO: Es gibt hier auch noch das problem, dass eigentlich nur auf dem inneren, i.e. ohne ghostcells der fehler evaluiert werden solte</span>
                <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">while</span> <span class="n">t2</span> <span class="o">&lt;</span> <span class="n">max_steps</span> <span class="ow">and</span> <span class="n">t2</span> <span class="o">&lt;</span> <span class="n">t</span> <span class="o">+</span> <span class="n">extra_steps</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t2</span> <span class="p">:</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_transform_data</span><span class="p">(</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">predict_single_step</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                                <span class="n">initial</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span>

                <span class="n">initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="n">t2</span> <span class="p">:</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># measure error, prediction slice is used to compare only the inner part of the data/ neglect ghost cells</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">errors</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate_one_step</span><span class="p">(</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t2</span> <span class="p">:</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span><span class="p">],</span>
                    <span class="n">supervision_data</span><span class="p">[</span><span class="n">t2</span> <span class="p">:</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">errrofunction</span><span class="o">=</span><span class="n">error_function</span><span class="p">,</span>
                    <span class="n">mean_norm</span><span class="o">=</span><span class="n">mean_norm</span><span class="p">,</span>
                    <span class="n">error_stop</span><span class="o">=</span><span class="n">error_stop</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># TODO: Hier muessen noch parameter von _evaluate_one_step gesetzt werden, die nicht allgemein in der baseclass sein muessen: Kwargs?</span>
                <span class="c1"># TODO: Es gibt hier auch noch das problem, dass eigentlich nur auf dem inneren, i.e. ohne ghostcells der fehler evaluiert werden solte</span>
                <span class="n">t2</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">prediction</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span><span class="p">][:</span><span class="n">t2</span><span class="p">],</span> <span class="n">errors</span><span class="p">[:</span><span class="n">t2</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase.reservoir_transient">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase.reservoir_transient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reservoir_transient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">predict_on_transient</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transient dynamics of the reservoirs. Updates the reservoir states and optionally predicts one step ahead on the transient dynamics, without reusing the predictions.</span>

<span class="sd">        Args:</span>
<span class="sd">            input: np.ndarray[float]</span>
<span class="sd">                input data for the transient dynamics</span>
<span class="sd">            predict_on_transient: bool</span>
<span class="sd">                if True, one step-ahead predictions are performed on transient data and returned, else only the reservoir states are updated</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Updating reservoir nodes on transient dynamics.&quot;</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.reservoir_transient</span><span class="se">\t\t</span><span class="s2">Input shape: </span><span class="si">{</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># add ghostcells to input data to fullfill boundary condition</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span>
            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># destinguish, whether to predict on transient or not</span>
        <span class="k">if</span> <span class="n">predict_on_transient</span><span class="p">:</span>
            <span class="n">prediction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_debug_parallelreservoirs</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;ParallelReservoir.reservoir_transient</span><span class="se">\t\t</span><span class="s2">Prediction shape: </span><span class="si">{</span><span class="n">prediction</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># predict one step ahead on transient data, without reusing the predictions</span>
            <span class="c1">## the order of the loops is irelevant, because the reservoirs are not interacting, but all time steps and all reservoirs need to be used</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                    <span class="n">prediction</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inv_transform_data</span><span class="p">(</span>
                        <span class="n">res</span><span class="o">.</span><span class="n">predict_single_step</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                                <span class="nb">input</span><span class="p">[</span><span class="n">t</span> <span class="p">:</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
                    <span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">prediction</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span>
            <span class="p">]</span>  <span class="c1"># return prediction without ghostcells</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Update the reservoir states on the transient data</span>
            <span class="c1"># All time steps can be used at ones, because no interaction of the reservoirs is used</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">input_t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span>
                    <span class="nb">input</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">fraction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span>
                <span class="p">):</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">propagate_reservoir_state</span><span class="p">(</span><span class="n">input_t</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_single_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase._initialize_reservoirs">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._initialize_reservoirs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_reservoirs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ReservoirComputer</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the reservoirs for the parallel reservoirs using :code:`rc_grid_shape`, which specifies how many reservoirs in each dimension are used.</span>

<span class="sd">        Args:</span>
<span class="sd">            seed (int): Seed for the random number generator, used for initializing the reservoirs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[ReservoirComputer]: The list of initialized reservoirs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">ReservoirComputer</span><span class="p">(</span>
                <span class="n">nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">res_nodes</span><span class="p">,</span>
                <span class="n">degree</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adj_degree</span><span class="p">,</span>
                <span class="n">leakage</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">res_leakage</span><span class="p">,</span>
                <span class="n">spectral_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">adj_spectralrad</span><span class="p">,</span>
                <span class="n">input_scaling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_scaling</span><span class="p">,</span>
                <span class="n">input_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">res_input_length</span><span class="p">,</span>
                <span class="n">input_bias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_bias</span><span class="p">,</span>
                <span class="n">output_bias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_bias</span><span class="p">,</span>
                <span class="n">regularization</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_regularization</span><span class="p">,</span>
                <span class="n">training_includeinput</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_includeinput</span><span class="p">,</span>
                <span class="n">identical_inputmatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_input</span><span class="p">,</span>
                <span class="n">identical_adjacencymatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_adjacencymatrix</span><span class="p">,</span>
                <span class="n">identical_outputmatrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identical_output</span><span class="p">,</span>
                <span class="n">reset_matrices</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">))</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase._initialize_reservoir_slices">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._initialize_reservoir_slices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_reservoir_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">slice</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prepare the reservoir slices for different reserovirs. First two dimensions are ignored, because they are :code:`(time_steps, variables)`/ not spatial.</span>
<span class="sd">        In each spatial dimension of length :math:`dim`, the slices for reservoir number :math:`i` (w.r.t. this dimension) of total number of reservoirs :math:`n` is chosen to be :code:`slice(start : stop)`, where</span>

<span class="sd">        .. math::</span>

<span class="sd">            \text{start} = i \cdot \left\lfloor\frac{dim}{n}\right\rfloor\quad\text{and}\quad\text{stop} = (i+1) \cdot \left\lfloor\frac{dim}{n}\right\rfloor + 2 \cdot \text{ghosts}.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple[slice]]: List of slices for each reservoir</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change name &#39;data_slices?&#39;</span>
        <span class="c1"># NOTE This only cares about spatial dimensions so far. Temporal and variable dimensions should be added here or need to be added in the application?</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop over all reservoirs</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">):</span>
            <span class="n">mult_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">)</span>

            <span class="c1"># create slice</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">system_variables</span><span class="p">))</span>
                <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="nb">slice</span><span class="p">(</span>
                        <span class="n">mult_index</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">mult_index</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_grid_shape</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                        <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">slices</span></div>


    <span class="c1"># TODO: JIT</span>
<div class="viewcode-block" id="ParallelReservoirsBase._boundary_condition">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._boundary_condition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_boundary_condition</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">add_ghostcells</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The function enforces boundary conditions on all spatial dimensions and returns the result.</span>
<span class="sd">            Either boundary cells are used as ghost cells or ghost cells are added.</span>
<span class="sd">            Ghost cell values depend on the boundary condition.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Input data in region to be predicted. Shape is :code:`(time_steps, variables, *spatial_shape)`.</span>
<span class="sd">            add_ghostcells (bool): If True, the boundary condition is fullfilled by adding ghostcells, else the outercells of the array are updated to fullfill the boundary condition.</span>

<span class="sd">        Return:</span>
<span class="sd">            np.ndarray: The extended array of size :code:`data.shape` or :code:`data.shape+2*window_size`, depending on :code:`add_ghostcells`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The boundary condition is applied to spatial dimensions only. Therefore, the first and second dimension of the input :code:`data` is ignored.</span>

<span class="sd">        Attention:</span>
<span class="sd">            This has not been tested for arbitrary dimensions. Only up to 2D.</span>
<span class="sd">            Might be useful to be precompiled(Numba-JIT), it runs in every time step</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_ghostcells</span><span class="p">:</span>
            <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span>
            <span class="n">increased_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># interior</span>
            <span class="c1"># ind = [slice(self.rc_ghosts, -self.rc_ghosts) for _ in range(len(shape))]</span>
            <span class="c1"># ind[0], ind[1] = slice(shape[0]), slice(shape[1])</span>
            <span class="n">increased_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">remove_ghosts</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">increased_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="c1"># boundary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">==</span> <span class="s2">&quot;Periodic&quot;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">increased_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">]</span> <span class="o">=</span> <span class="n">increased_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span>
                <span class="p">]</span>
                <span class="n">increased_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="n">increased_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="p">:</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">increased_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">]</span>
                <span class="n">increased_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">increased_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">dim</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">==</span> <span class="s2">&quot;NoFlux&quot;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">increased_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span><span class="p">]</span> <span class="o">=</span> <span class="n">increased_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
                <span class="p">]</span>
                <span class="n">increased_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="n">increased_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="p">:</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">increased_data</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rc_ghosts</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
                <span class="p">]</span>
                <span class="n">increased_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">increased_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">dim</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">increased_data</span></div>


    <span class="c1"># TODO: JIT</span>
<div class="viewcode-block" id="ParallelReservoirsBase._evaluate_one_step">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._evaluate_one_step">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_one_step</span><span class="p">(</span>
        <span class="n">prediction</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">supervision_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">errrofunction</span><span class="o">=</span><span class="s2">&quot;NRMSE&quot;</span><span class="p">,</span>
        <span class="n">mean_norm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">error_stop</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Evaluate the prediction of one time step using the error function :code:`errorfunction`.</span>
<span class="sd">        If :code:`errorfunction =&quot;NRMSE&quot;`, the normalized root mean square error</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\|\vec{u}(t)-\vec{u}^{\mathrm{true}}(t)\|_2}{\langle\|\vec{u}^{\mathrm{true}}(t)\|^2\rangle_{\mathrm{t}}^{1/2}}</span>

<span class="sd">        is used.</span>

<span class="sd">        Args:</span>
<span class="sd">            prediction (np.ndarray):</span>
<span class="sd">                Prediction of the system at one time step. Shape is :code:`(variables, *spatial_shape)`.</span>
<span class="sd">            supervision_data (np.ndarray):</span>
<span class="sd">                Supervision data for the prediction. Shape is :code:`(variables, *spatial_shape)`.</span>
<span class="sd">            errorfunction (str):</span>
<span class="sd">                Error function to evaluate the prediction. Only the nomalized root mean square error :code:`&quot;NRMSE&quot;` is implemented so far.</span>
<span class="sd">            mean_norm (float):</span>
<span class="sd">                Mean norm of the supervision data, is used to normalize the error root mean square error.</span>
<span class="sd">            error_stop (float):</span>
<span class="sd">                Threshold for the error function. Iterative predictions are stopped if the error is above the threshold.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool:</span>
<span class="sd">                True if the error is below the threshold :code:`error_stop`, else False.</span>

<span class="sd">        Warning: This method is not tested and might have errors!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(prediction.shape, supervision_data.shape)</span>
        <span class="k">if</span> <span class="n">errrofunction</span> <span class="o">==</span> <span class="s2">&quot;NRMSE&quot;</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">prediction</span> <span class="o">-</span> <span class="n">supervision_data</span><span class="p">)</span> <span class="o">/</span> <span class="n">mean_norm</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">error_stop</span> <span class="o">&gt;</span> <span class="n">error</span><span class="p">),</span> <span class="n">error</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only Normalized Root Mean Square Error &#39;NRMSE&#39; is implemented so far.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase._get_input_length">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._get_input_length">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_input_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Depends on dimension reduction method.</span>

<span class="sd">        Get the length of the input data for each parallel object of class :code:`ReservoirComputer`. Depends on Dimension Reduction fraction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The length of the input data for each :code:`ReservoirComputer`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase._transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._transform_data">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Depends on dimension reduction method.</span>

<span class="sd">        Transform the data to the shape used in the reservoirs.</span>
<span class="sd">        Data of shape :code:`(time_steps, variables, *spatial_shape)` is transformed to :code:`(time, res_variables)`, where all variables and spatial shapes are used in the dimension reduction and flatted into one dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed. Second dimension chooses different variables and will be used in dimension reduction. All others are spatial dimensions and are flatted as well.</span>
<span class="sd">            fraction (float):</span>
<span class="sd">                Fraction of variables that actually enters the reservoir after dimension reduction.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data. First dimension is temporal and not transformed. Rest is flattened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase._inv_transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase._inv_transform_data">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inv_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Depends on dimension reduction method.</span>

<span class="sd">        Inverse dimension reduction transformation of the flatted reservoir data :code:`data`.</span>
<span class="sd">        The output is transformed to the geometric shape of the output prediction.</span>
<span class="sd">        First dimension of input :code:`data` is temporal and not transformed. Second dimension is split into different variables and spatial dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Inverse transformed data. First dimension is temporal and not transformed. Rest is reshaped to number of variables and spatial shape.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase.save">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase.save">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save a ParallelReservoir to pkl file</span>

<span class="sd">        A possible use case of this is to conserve a trained multi-reservoir for later.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str):</span>
<span class="sd">                name of file to generate</span>

<span class="sd">        Warning: This function might be depracated. Else, might need to be put to derived classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span></div>


<div class="viewcode-block" id="ParallelReservoirsBase.load">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsBase.load">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load a ParallelReservoir from pkl file</span>

<span class="sd">        A possible use case of this is to load a trained model and perform further</span>
<span class="sd">        predictions without having to do the training again.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str):</span>
<span class="sd">                name of file to read in</span>

<span class="sd">        Warning: This function might be depracated. Else, might need to be put to derived classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="ParallelReservoirs">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirs">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelReservoirs</span><span class="p">(</span><span class="n">ParallelReservoirsBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use multiple Reservoir Computers in parallel to predict high dimensional systems without dimensionality reduction.</span>
<span class="sd">    Parallel is to be understood in terms of domain splitting of the input data.</span>
<span class="sd">    This class uses the base class :code:`ParallelReservoirsBase`, which initiates Reservoirs of the class :code:`ReservoirComputer` and handles the training and prediction of the parallel reservoirs.</span>

<span class="sd">    **Initialization**:</span>

<span class="sd">    - Only base class setup is done. No further initialization is needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">Parameter</span><span class="p">:</span> <span class="n">ParallelReservoirsArguments</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Setting up parallel reservoirs.&quot;</span><span class="p">)</span>
        <span class="c1"># init base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Class ParallelReservoirs should not have dimension reduction, but got dr_fraction != 1.&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">loglevel_info_multiple_run</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Done.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ParallelReservoirs._get_input_length">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirs._get_input_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_input_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the length of the input data for each parallel object of class :code:`ReservoirComputer`. Without dimension reduction, the input length is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \text{input length} = \prod_{i=1}^{d} \left( \frac{N_i}{R_i} + 2 g\right)</span>

<span class="sd">        where :math:`d` is the number of spatial dimensions of the predicted system, :math:`N_i` is the number of support points in the :math:`i`-th dimension, :math:`R_i` is the number of parallel reservoirs in the :math:`i`-th dimension, :math:`g` is the number of ghost cells used aroud the predicted region of each reservoir.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The length of the input data for each :code:`ReservoirComputer`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirs._transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirs._transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform the data to the shape used in the reservoirs.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed. Second dimension chooses different variables and will be flattend. All others are spatial dimensions and are flatted as well.</span>
<span class="sd">            fraction (float):</span>
<span class="sd">                Fraction of variables that actually enters the reservoir after dimension reduction. Should be one. Is not used.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data. First dimension is temporal and not transformed. Rest is flattened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_DRRC</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir._transform_dataTransormation</span><span class="se">\t</span><span class="s2">Input shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and transformed shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="ParallelReservoirs._inv_transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirs._inv_transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inv_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverse transformation of the data flatted reservoir data to the geometric shape. First dimension of input is temporal and not transformed. Second dimension is split into different variables and spatial dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data. First dimension is temporal and not transformed. Rest is reshaped to number of variables and spatial shape.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
            <span class="n">loglevel_debug_DRRC</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ParallelReservoir._inv_transform_data</span><span class="se">\t\t</span><span class="s2">Inverse transormation input shape: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and transformed shape </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="ParallelReservoirsFFT">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsFFT">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelReservoirsFFT</span><span class="p">(</span><span class="n">ParallelReservoirsBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use multiple Reservoir Computers in parallel to predict high dimensional systems using largest modes of an FFT for dimensionality reduction.</span>
<span class="sd">    Parallel is to be understood in terms of domain splitting of the input data.</span>
<span class="sd">    This class uses the base class :code:`ParallelReservoirsBase`, which initiates Reservoirs of the class :code:`ReservoirComputer` and handles the training and prediction of the parallel reservoirs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">Parameter</span><span class="p">:</span> <span class="n">ParallelReservoirsArguments</span><span class="p">,</span>
        <span class="n">prediction_model</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Initialization**:</span>

<span class="sd">        - Calculates or loads the largest FFT modes for the given datatype, i.e. model and parameters, and input and output dimension for each parallel Reservoir Computer.</span>

<span class="sd">        - Base class: Set up reservoir and parallel-reservoir parameters, initialize reservoirs and slices.</span>

<span class="sd">        Args:</span>

<span class="sd">            args (ParallelReservoirsArguments):</span>
<span class="sd">                All needed arguments in a dataclass object.</span>
<span class="sd">            prediction_model (str):</span>
<span class="sd">                Name of the model to be predicted. Used to load or choose FFT modes with largest amplitude.</span>
<span class="sd">            **kwargs : dict</span>
<span class="sd">                nr_fft_datasets (int):</span>
<span class="sd">                    The number of training data sets used to train the FFT. If not used all 10 training data sets are used.</span>
<span class="sd">                    This is useful for computations with not enough memory for the full training.</span>

<span class="sd">        Warning:</span>
<span class="sd">            The same modes are used everywhere and choosen on all training data sets and all domains.</span>
<span class="sd">            Hence, the class only works if two conditions are met:</span>
<span class="sd">            1. The predicted Systems are homogeneous.</span>
<span class="sd">            2. All data sets need to be sampled from the same attractor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># precompute tuple of spatial axes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_shape</span><span class="p">)))</span>

        <span class="c1"># init list of indices of largest modes (will be overwritten with ordered list, decreasing)</span>
        <span class="c1">## The initialization here is needed to run the transform function, to calculate the modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span><span class="p">))</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">prediction_model</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">)</span>
        <span class="n">fft_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;/Data/FFT/&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;nr_fft_datasets&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nr_fft_datasets&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of training data sets for PCA can be 10 at max.&quot;</span>
                <span class="p">)</span>
            <span class="n">nr_trainings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nr_fft_datasets&quot;</span><span class="p">]</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_trainedon</span><span class="si">{</span><span class="n">nr_trainings</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nr_trainings</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">temp_skip</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fft_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Loading FFT modes for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">fft_path</span><span class="o">+</span><span class="n">filename</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fft_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Choosing FFT modes for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">prediction_model</span> <span class="o">==</span> <span class="s2">&quot;1D_KuramotoSivashinsky&quot;</span><span class="p">:</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="mi">80000</span> <span class="o">//</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Gather triningdata.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
                            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Data/</span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2">/TrainingData</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.npy&quot;</span>
                            <span class="p">)[:</span><span class="n">max_len</span><span class="p">:</span><span class="n">temp_skip</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_trainings</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">fft_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">))</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">prediction_model</span> <span class="o">==</span> <span class="s2">&quot;2D_AlievPanfilov&quot;</span><span class="p">:</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="mi">20000</span> <span class="o">//</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Gather triningdata.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
                            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Data/</span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2">/TrainingData</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.npz&quot;</span>
                            <span class="p">)[</span><span class="s2">&quot;vars&quot;</span><span class="p">][:</span><span class="n">max_len</span><span class="p">:</span><span class="n">temp_skip</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_variables</span><span class="p">],</span>
                            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_trainings</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">fft_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">fft_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">))</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Training data for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> not found.&quot;</span>
                <span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Choosing FFT modes for domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">fft_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> Samples/ timesteps.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># select temporal max of largest modes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_data</span><span class="p">(</span><span class="n">fft_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Saving FFT modes for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">fft_path</span><span class="o">+</span><span class="n">filename</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">fft_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>

        <span class="c1"># create object to invert the ordering of the largest modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_largest_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invert_largest_modes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inv_largest_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="p">)</span>
        <span class="c1"># save an ordered list of indices of the largest modes</span>
        <span class="c1"># take only self.dimensionreduction_fraction of this ordered list --&gt; cookie cutter for transform</span>

<div class="viewcode-block" id="ParallelReservoirsFFT._get_input_length">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsFFT._get_input_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_input_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the length of the input data for each parallel object of class :code:`ReservoirComputer`. With dimension reduction, the input length is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \text{input length} = \left\lfloor f \times \prod_{i=1}^{d} \left( \frac{N_i}{R_i} + 2g \right) \right\rfloor</span>

<span class="sd">        where :math:`f` is the fraction :code:`self.dimensionreduction_fraction` of the dimensions used, :math:`d` is the number of spatial dimensions of the predicted system, :math:`N_i` is the number of support points in the :math:`i`-th dimension, :math:`R_i` is the number of parallel reservoirs in the :math:`i`-th dimension, :math:`g` is the number of ghost cells used aroud the predicted region of each reservoir.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The length of the input data for each :code:`ReservoirComputer`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsFFT._transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsFFT._transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform and reduce the data using the largest modes of the FFT. Flattening all but the first dimension to the shape used in the reservoirs.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed. Second dimension chooses different variables, all others are spatial dimensions.</span>
<span class="sd">            fraction (float):</span>
<span class="sd">                Fraction of variables that actually enters the reservoir after dimension reduction.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data. First dimension is temporal and not transformed. Rest is flattened.</span>

<span class="sd">        Warning: Tested only in 1d</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">res_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">)</span>

        <span class="c1"># Create tests if the following arrays are zeros everywhere, for different shapes. Else we discard this information</span>
        <span class="c1"># print(res_data.imag[..., 0])</span>
        <span class="c1"># print(res_data.imag[..., np.ceil(self.res_domain_size[-1]/2).astype(int):])</span>

        <span class="c1"># last axis is always factor 2 shorter do to symmetry of real data</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">res_data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                <span class="n">res_data</span><span class="o">.</span><span class="n">imag</span><span class="p">[</span>
                    <span class="o">...</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">],</span>
            <span class="p">],</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span>
            <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">largest_modes</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)]</span>
        <span class="p">]</span>  <span class="c1"># only take the first fraction of the largest modes</span></div>


<div class="viewcode-block" id="ParallelReservoirsFFT._inv_transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsFFT._inv_transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inv_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverse FFT transformation of the data flatted reservoir output (all components need to be predicted and are realigned to spatial shape). Transformed back to the geometric shape.</span>
<span class="sd">        This includes the boundary which will not be used when stitching the reservoir predictions together.</span>
<span class="sd">        First dimension of input is temporal and not transformed. Second dimension is split into different variables and spatial dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed, of shape :code:`(time_steps, reservoir_variables)`. First dimension is temporal and not transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data of shape :code:`(time_steps, variables, *spatial_shape)`. First dimension is temporal and not transformed. Rest is reshaped to number of variables and spatial shape.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The input data is the output of one reservoir, which corresponds to one spatial domain.</span>

<span class="sd">        Warning: Tested only in 1d.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># undo ordering of largest modes</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_largest_modes</span><span class="p">]</span>

        <span class="c1"># reshape to spatial shape</span>
        <span class="c1">## first half of last axes contains real part, second half imaginary part</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">)</span>

        <span class="c1"># create complex data, last axis is always factor 2 shorter do to symmetry of real data</span>
        <span class="n">fft_components</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">cmplx_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">fft_components</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="n">cmplx_data</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">fft_components</span><span class="p">]</span>
        <span class="n">cmplx_data</span><span class="o">.</span><span class="n">imag</span><span class="p">[</span>
            <span class="o">...</span><span class="p">,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">fft_components</span><span class="p">:]</span>

        <span class="c1"># inverse fft</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">cmplx_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spatial_axes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ParallelReservoirsPCA">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsPCA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelReservoirsPCA</span><span class="p">(</span><span class="n">ParallelReservoirsBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use multiple Reservoir Computers in parallel to predict high dimensional systems with using a PCA for dimensionality reduction.</span>
<span class="sd">    Parallel is to be understood in terms of domain splitting of the input data.</span>
<span class="sd">    This class uses the base class :code:`ParallelReservoirsBase`, which initiates Reservoirs of the class :code:`ReservoirComputer` and handles the training and prediction of the parallel reservoirs.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">Parameter</span><span class="p">:</span> <span class="n">ParallelReservoirsArguments</span><span class="p">,</span>
        <span class="n">prediction_model</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **Initialization**:</span>

<span class="sd">        - Trains or loads the PCA object for the given datatype, i.e. model and parameters, and output dimension for each parallel Reservoir Computer.</span>
<span class="sd">        Due to memory constrains, the pca-training data is taken from 10 training data sets and only each second time step is used. In addition for multiple parallel reservoirs the training data is sampled from all domains. In this case, the number of timesteps per domain is shortened (devided by number of domains) to keep the number of timesteps independet of the number of parallel reservoirs.</span>
<span class="sd">        Computational Complexity: :math:`\mathcal{O}(n\cdot d^2)`, where :math:`n` is the number of samples and :math:`d` is the number of dimensions.</span>

<span class="sd">        - Base class: Set up reservoir and parallel-reservoir parameters, initialize reservoirs and slices.</span>

<span class="sd">        Args:</span>
<span class="sd">            args (ParallelReservoirsArguments):</span>
<span class="sd">                All needed arguments in a dataclass object.</span>
<span class="sd">            prediction_model (str):</span>
<span class="sd">                Name of the model to be predicted. Used to load or train the PCA object.</span>
<span class="sd">            **kwargs : dict</span>
<span class="sd">                nr_pca_trainings (int):</span>
<span class="sd">                    The number of training data sets used to train the PCA. If not used all 10 training data sets are used.</span>
<span class="sd">                    This is useful for computations with not enough memory for the full training.</span>

<span class="sd">        Warning:</span>
<span class="sd">            The same PCA is used everywhere and trained on all training data sets and all domains.</span>
<span class="sd">            Hence, the class only works if two conditions are met:</span>
<span class="sd">            1. The predicted Systems are homogeneous.</span>
<span class="sd">            2. All data sets need to be sampled from the same attractor.</span>

<span class="sd">        Warining:</span>
<span class="sd">            Training PCAs with many parallel reservoirs and large ghost cells can be memory intensive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">Parameter</span><span class="p">)</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="n">prediction_model</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">)</span>
        <span class="n">pca_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;/Data/PCA/&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;nr_pca_trainings&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nr_pca_trainings&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of training data sets for PCA can be 10 at max.&quot;</span>
                <span class="p">)</span>
            <span class="n">nr_trainings</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;nr_pca_trainings&quot;</span><span class="p">]</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_trainedon</span><span class="si">{</span><span class="n">nr_trainings</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nr_trainings</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">temp_skip</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">pca_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Loading PCA for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">pca_path</span><span class="o">+</span><span class="n">filename</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pca</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">pca_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Training PCA for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">prediction_model</span> <span class="o">==</span> <span class="s2">&quot;1D_KuramotoSivashinsky&quot;</span><span class="p">:</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="mi">80000</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Gather pca triningdata.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">pca_trainingdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
                            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Data/</span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2">/TrainingData</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.npy&quot;</span>
                            <span class="p">)[:</span><span class="n">max_len</span><span class="p">:</span><span class="n">temp_skip</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_trainings</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">pca_trainingdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">pca_trainingdata</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">))</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">prediction_model</span> <span class="o">==</span> <span class="s2">&quot;2D_AlievPanfilov&quot;</span><span class="p">:</span>
                <span class="n">max_len</span> <span class="o">=</span> <span class="mi">20000</span> <span class="o">//</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoirs</span><span class="p">))</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                    <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Gather pca triningdata.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">pca_trainingdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_condition</span><span class="p">(</span>
                            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                                <span class="nb">str</span><span class="p">(</span><span class="n">Config</span><span class="o">.</span><span class="n">get_git_root</span><span class="p">())</span>
                                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;/Data/</span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2">/TrainingData</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">.npz&quot;</span>
                            <span class="p">)[</span><span class="s2">&quot;vars&quot;</span><span class="p">][:</span><span class="n">max_len</span><span class="p">:</span><span class="n">temp_skip</span><span class="p">,</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">system_variables</span><span class="p">],</span>
                            <span class="n">add_ghostcells</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_trainings</span><span class="p">)</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">pca_trainingdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">pca_trainingdata</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reservoir_slices</span><span class="p">))</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Training data for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> not found.&quot;</span>
                <span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Training PCA for domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">pca_trainingdata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> Samples.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">pca_trainingdata</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pca_trainingdata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">loglevel_info_multiple_run</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Saving PCA for </span><span class="si">{</span><span class="n">prediction_model</span><span class="si">}</span><span class="s2"> with domain size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">pca_path</span><span class="o">+</span><span class="n">filename</span><span class="o">+</span><span class="s1">&#39;.pkl&#39;</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">pca_path</span> <span class="o">+</span> <span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>

<div class="viewcode-block" id="ParallelReservoirsPCA._get_input_length">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsPCA._get_input_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_input_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the length of the input data for each parallel object of class :code:`ReservoirComputer`. With dimension reduction, the input length is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \text{input length} = \left\lfloor f \times \prod_{i=1}^{d} \left( \frac{N_i}{R_i} + 2g \right) \right\rfloor</span>

<span class="sd">        where :math:`f` is the fraction :code:`self.dimensionreduction_fraction` of the dimensions used, :math:`d` is the number of spatial dimensions of the predicted system, :math:`N_i` is the number of support points in the :math:`i`-th dimension, :math:`R_i` is the number of parallel reservoirs in the :math:`i`-th dimension, :math:`g` is the number of ghost cells used aroud the predicted region of each reservoir.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The length of the input data for each :code:`ReservoirComputer`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dr_fraction</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="ParallelReservoirsPCA._transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsPCA._transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform and reduce the data using the largest explained variances of the PCA. Flattening all but the first dimension to the shape used in the reservoirs.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed. First dimension is temporal and not transformed. Second dimension chooses different variables, all others are spatial dimensions.</span>
<span class="sd">            fraction (float):</span>
<span class="sd">                Fraction of variables that actually enters the reservoir after dimension reduction.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray:</span>
<span class="sd">                Transformed data. First dimension is temporal and not transformed. Rest is flattened.</span>

<span class="sd">        Warning: Not implemented</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))[</span>
            <span class="p">:,</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_output_length</span><span class="p">)</span>
        <span class="p">]</span></div>


<div class="viewcode-block" id="ParallelReservoirsPCA._inv_transform_data">
<a class="viewcode-back" href="../../packages/drrc.parallelreservoirs.html#drrc.parallelreservoirs.ParallelReservoirsPCA._inv_transform_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inv_transform_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverse PCA transformation of the data flatted reservoir output (all components need to be predicted). Transformed back to the geometric shape.</span>
<span class="sd">        This includes the boundary which will not be used when stitching the reservoir predictions together.</span>
<span class="sd">        First dimension of input is temporal and not transformed. Second dimension is split into different variables and spatial dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):</span>
<span class="sd">                Data to be transformed, of shape :code:`(time_steps, reservoir_variables)`. First dimension is temporal and not transformed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Transformed data of shape :code:`(time_steps, variables, *spatial_shape)`. First dimension is temporal and not transformed. Rest is reshaped to number of variables and spatial shape.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The input data is the output of one reservoir, which corresponds to one spatial domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">res_domain_size</span><span class="p">)</span>
        <span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Luk Fleddermann, Gerrit Wellecke.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>